import os
from datetime import datetime, timedelta
from random import choice, randint
import re

from aiogram import Router, F
from aiogram.filters import CommandStart
from aiogram.fsm.state import StatesGroup, State
from dotenv import load_dotenv
from aiogram.types import Message, CallbackQuery, InputFile, BufferedInputFile, \
    Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo, \
    LabeledPrice, PreCheckoutQuery, ReplyKeyboardMarkup, KeyboardButton

from messages import MessageText
from aiogram.fsm.context import FSMContext


load_dotenv()  # –∑–∞–≥—Ä—É–∂–∞–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞ .env –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
router = Router()
CHAT_ID = os.getenv('CHAT_ID')



print('start')

# ITEMS

photo_types = {
    'jpg': list(range(1, 6)) + list(range(7, 17)) + list(range(18, 22)) + list(
    range(24, 35)) + list(range(39, 42)),
    'png': [6, 17, 37],
    'jpeg': [22, 23, 35, 36, 38] + list(range(42, 51))
}



class Teams(StatesGroup):
    # teams = [
    #     (team1, points1),
    #     (team2, points2)
    # ]
    teams = State()
    # round = {
    #     'team_id': id
    #     'time_start': datatime,
    #     'time_end': datatime,
    #     'ok': points,
    #     'not_ok': points
    # }
    round = State()
    # mode = 0 / - 1
    mode = State()
    round_cnt = State()  # –°—á–µ—Ç—á–∏–∫ —Ä–∞—É–Ω–¥–æ–≤


RANDOM_TEAM_NAMES = [
    "üèÜ –ú–µ–º–Ω—ã–µ –õ–µ–≥–µ–Ω–¥—ã",
    "üò¨ –®–∫–æ–ª–∞ –∫—Ä–∏–Ω–∂–∞",
    "ü§£ –õ–µ–≥–µ–Ω–¥—ã —Ä–æ—Ñ–ª–æ–≤",
    "üéµ –ü–∞–Ω—Ç–µ–æ–Ω –ë–∞—è–Ω—á–∏–∫–æ–≤",
    "ü§ñ –ö–µ–∫–∞—Ç–µ–ª–∏ 3000",
    "üòÇ –§–∞–±—Ä–∏–∫–∞ –ª—É–ª–∑–æ–≤",
    "ü¶ñ –ú–µ–º–æ–∑–∞–≤—Ä—ã",
    "üòê –ü–æ—á—Ç–∏ —Å–º–µ—à–Ω–æ",
    "üî• –ö—Ä–∏–Ω–∂–µ–≤–∏–∫–∏",
    "‚öîÔ∏è –ì–µ—Ä–æ–∏ –ë–∞—è–Ω–∞",
    "üåà –î–µ—Ç–∏ –õ–æ–ª–æ–ª–µ–Ω–¥–∞"
]



# KEYBOARDS
def get_main_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text='üéÆ –ù–æ–≤–∞—è –∏–≥—Ä–∞')],
            [KeyboardButton(text='üìú –ü—Ä–∞–≤–∏–ª–∞')],
            [KeyboardButton(text='üí∞ –ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å')],
            [KeyboardButton(text='‚ùì –ü–æ–º–æ—â—å')],
        ],
        resize_keyboard=True,
    )

def get_mode() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text='ü§Ø –í—ã—á–∏—Ç–∞—Ç—å 1 –±–∞–ª–ª –ø—Ä–∏ –ø—Ä–æ–ø—É—Å–∫–µ', callback_data=f'mode_1')],
        [InlineKeyboardButton(text='ü•± –ù–ï –≤—ã—á–∏—Ç–∞—Ç—å –±–∞–ª–ª—ã –ø—Ä–∏ –ø—Ä–æ–ø—É—Å–∫–µ', callback_data=f'mode_2')],
    ])

def get_teams_markup(first = False) -> InlineKeyboardMarkup:
    teams_markup = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text='üé≤ –†–∞–Ω–¥–æ–º–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ', callback_data='random_team')],
        [InlineKeyboardButton(text='üõë –ë–æ–ª—å—à–µ –Ω–µ—Ç –∫–æ–º–∞–Ω–¥', callback_data='finish_teams')],
    ])
    if first:
        teams_markup = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text='üé≤ –†–∞–Ω–¥–æ–º–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ',
                                  callback_data='random_team')],
        ])
    return teams_markup

def get_start(team_id) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text='üöÄ –°—Ç–∞—Ä—Ç', callback_data=f'play_{team_id}')],
    ])

def get_select_res() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text='‚úÖ –£–≥–∞–¥–∞–ª–∏', callback_data=f'res_ok')],
        [InlineKeyboardButton(text='‚ùå –ü—Ä–æ–ø—É—Å—Ç–∏–ª–∏', callback_data=f'res_notok')],
    ])

def get_select_res_end() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text='‚úÖ –£–≥–∞–¥–∞–ª–∏', callback_data='res-end_ok')],
        [InlineKeyboardButton(text='‚ùå –ü—Ä–æ–ø—É—Å—Ç–∏–ª–∏', callback_data='res-end_notok')],
    ])

def get_teams_list(teams) -> InlineKeyboardMarkup:
    keyboard = [[InlineKeyboardButton(text=teams[i][0],
                                      callback_data=f'team_{i}')] for i in
                range(len(teams))]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

def get_continue() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text='üéâ –ò–≥—Ä–∞–µ–º –¥–∞–ª—å—à–µ', callback_data='continue_1')],
        [InlineKeyboardButton(text='üèÅ –ó–∞–∫–æ–Ω—á–∏—Ç—å –∏–≥—Ä—É', callback_data='continue_0')],
    ])


donation = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text='üå•Ô∏è Cloudtips',
                          url='https://pay.cloudtips.ru/p/d1db20d4')],
])


# HELPERS
async def get_rules(message: Message=None, callback: CallbackQuery=None):
    if message:
        await message.answer(MessageText.mems_rules)
    else:
        await callback.message.answer(MessageText.mems_rules)

def mode_filter(callback: CallbackQuery):
    pattern = r"^mode_\d+$"
    return re.match(pattern, callback.data) is not None


def get_names_list(teams: list):
    return [item[0] for item in teams]


def get_photo_type(img_id):
    for key, values in photo_types.items():
        if img_id in values:
            return key

def get_random_photo():
    img_id = randint(1, 50)
    img_type = get_photo_type(img_id)
    return f'https://storage.yandexcloud.net/memsgames/{img_id}.{img_type}'

def team_filter(callback: CallbackQuery):
    pattern = r"^team_\d+$"
    return re.match(pattern, callback.data) is not None


def play_filter(callback: CallbackQuery):
    pattern = r"^play_\d+$"
    return re.match(pattern, callback.data) is not None

def res_filter(callback: CallbackQuery):
    key = 'res'
    return key == callback.data.split('_')[0]

def res_end_filter(callback: CallbackQuery):
    key = 'res-end'
    return key == callback.data.split('_')[0]

def continue_filter(callback: CallbackQuery):
    pattern = r"^continue_\d+$"
    return re.match(pattern, callback.data) is not None








# ROUTER
@router.message(CommandStart())
async def cmd_start(message: Message):
    await message.bot.send_message(CHAT_ID, f'NewUser: @{message.from_user.username}')
    await message.answer(MessageText.start_memalias, reply_markup=get_main_keyboard())
    await get_rules(message=message)

@router.message(F.text == 'üìú –ü—Ä–∞–≤–∏–ª–∞')
async def rules(message: Message):
    await get_rules(message=message)

@router.message(F.text == 'üí∞ –ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å')
async def rules(message: Message):
    await message.answer(MessageText.donation, reply_markup=donation)

@router.message(F.text == '‚ùì –ü–æ–º–æ—â—å')
async def rules(message: Message):
    await message.answer(MessageText.help)

@router.message(F.text == 'üéÆ –ù–æ–≤–∞—è –∏–≥—Ä–∞')
async def new_game(message: Message, state: FSMContext):
    """–ù–∞—á–∞–ª–æ –Ω–æ–≤–æ–π –∏–≥—Ä—ã –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥."""
    await state.clear()
    await state.update_data(round_cnt=0)
    await message.answer(MessageText.start_game)
    await message.answer(MessageText.select_mode, reply_markup=get_mode())



@router.callback_query(mode_filter)
async def state_mode(callback: CallbackQuery, state: FSMContext):
    mode = callback.data.split('_')[1]
    await state.update_data(mode=- 1 if mode == '1' else 0)
    await callback.message.answer(MessageText.mode_1 if mode == '1' else MessageText.mode_2)
    await callback.message.answer(MessageText.create_teams, reply_markup=get_teams_markup(first=True))
    await state.set_state(Teams.teams)

@router.message(Teams.teams)
async def new_team(message: Message, state: FSMContext):
    team_name = message.text.strip()
    data = await state.get_data()
    teams = data.get("teams", [])
    if team_name in get_names_list(teams):
        await message.answer(text=MessageText.team_already_exist(team_name))
        return
    # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É —Å –±–∞–ª–ª–æ–º 0
    teams.append([team_name, 0])
    await state.update_data(teams=teams)
    # –ü—Ä–æ—Å–∏–º –≤–≤–µ—Å—Ç–∏ —Å–ª–µ–¥—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É –∏–ª–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—å
    await message.answer(
        MessageText.team_added(team_name),
        reply_markup=get_teams_markup()
    )

@router.callback_query(F.data == 'random_team')
async def random_team(callback: CallbackQuery, state: FSMContext):
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã."""
    data = await state.get_data()
    teams = data.get("teams", [])

    # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω–µ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è
    available_names = [name for name in RANDOM_TEAM_NAMES if name not in get_names_list(teams)]
    if not available_names:
        await callback.message.answer("–ë–æ–ª—å—à–µ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –Ω–∞–∑–≤–∞–Ω–∏–π –¥–ª—è –∫–æ–º–∞–Ω–¥.")
        return

    random_name = choice(available_names)
    teams.append([random_name, 0])
    await state.update_data(teams=teams)

    await callback.message.answer(
        MessageText.team_added(random_name),
        reply_markup=get_teams_markup()
    )

@router.callback_query(F.data == "finish_teams")
async def finish_collecting_teams(callback: CallbackQuery, state: FSMContext):
    # –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    teams = data.get("teams", [])
    # –í—ã–≤–æ–¥–∏–º —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥
    if teams:
        await callback.message.answer(MessageText.teams_end, reply_markup=get_teams_list(teams))
    else:
        await callback.message.answer("–ù–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥—ã. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞!")




@router.callback_query(team_filter)
async def play_team(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    teams = data.get("teams", [])
    team_id = int(callback.data.split('_')[1])
    round_cnt = data.get("round_cnt", 0) + 1
    await state.update_data(round_cnt=round_cnt)
    team_name = get_names_list(teams)[team_id]
    await callback.message.answer(MessageText.selected_team(team_name, round_cnt),
                                    reply_markup=get_start(team_id))





@router.callback_query(play_filter)
async def play_team(callback: CallbackQuery, state: FSMContext):
    team_id = int(callback.data.split('_')[1])
    current_time = datetime.now()
    time_plus_thirty_seconds = current_time + timedelta(seconds=30)
    time_plus_one_minute = current_time + timedelta(minutes=1)
    team_round = {
        'team_id': int(team_id),
        'time_start': current_time,
        'time_middle': time_plus_thirty_seconds,
        'time_end': time_plus_one_minute,
        'ok': 0,
        'not_ok': 0
    }
    await state.update_data(round=team_round)
    user_id = callback.from_user.id
    photo = get_random_photo()
    await callback.message.bot.send_photo(
        chat_id=user_id,
        photo=photo,
        # caption=str,
        reply_markup=get_select_res()
    )


@router.callback_query(res_filter)
async def play_forward(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    team_round = data.get('round', dict())
    current_time = datetime.now()
    time_middle = team_round.get('time_middle')
    time_end = team_round.get('time_end')
    markup = get_select_res()
    res = callback.data.split('_')[1]
    if res == 'ok':
        team_round['ok'] = team_round['ok'] + 1
    else:
        team_round['not_ok'] = team_round['not_ok'] + 1
    await state.update_data(round=team_round)

    if time_end > current_time > time_middle:
        await callback.message.answer(MessageText.left_time)

    if current_time > time_end:
        await callback.message.answer(MessageText.time_end)
        markup = get_select_res_end()

    user_id = callback.from_user.id
    photo = get_random_photo()
    await callback.message.bot.send_photo(
        chat_id=user_id,
        photo=photo,
        reply_markup=markup
    )

@router.callback_query(res_end_filter)
async def play_round_end(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    team_round = data.get('round', dict())
    team_id = team_round.get('team_id')
    round_cnt = data.get('round_cnt', 0)
    teams = data.get('teams')
    res = callback.data.split('_')[1]
    if res == 'ok':
        team_round['ok'] = team_round['ok'] + 1
    else:
        team_round['not_ok'] = team_round['not_ok'] + 1
    round_ok = team_round.get('ok')
    round_not_ok = team_round.get('not_ok')
    await callback.message.answer(MessageText.round_result(ok=round_ok, not_ok=round_not_ok))

    new_points = round_ok + (round_not_ok * data.get('mode'))
    teams[team_id][1] = teams[team_id][1] + new_points
    await state.update_data(teams=teams)

    await callback.message.answer(MessageText.all_results(teams, round_cnt), reply_markup=get_continue())

@router.callback_query(continue_filter)
async def continue_answer(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    teams = data.get('teams')
    status = callback.data.split('_')[1]
    if int(status):
        await callback.message.answer(MessageText.select_next_team, reply_markup=get_teams_list(teams))
    else:
        winner = max(teams, key=lambda team: team[1])
        await callback.message.answer(MessageText.end_game(winner[0]), reply_markup=get_main_keyboard())
        await state.clear()


